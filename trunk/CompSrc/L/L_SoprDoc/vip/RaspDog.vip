//******************************************************************************
//                                                      (c) корпорация Галактика
// Галактика 7.12 - Логистика
// автоматическое формирование накладных по ДО
//******************************************************************************

//автоматическое формирование приходных накладных по ДО
//согласно ПКП для группы VIP-договоров
//ПИР 101.25418


#include DOfuns.vih
#include SDfuns.vih
#include DelSopr.vih
#include makenakl.vih

#include docbuf.inc   // Универсальный буфер для формирования шапки документа
#include spdocbuf.inc // Универсальный буфер для формирования спецификации документа

//******************************************************************************

#doc
Назначение:
  автоматическое формирование накладных на отпуск по ДО
  разрез формирования распределения: ДО - Договор (Склад) - ПКП

        Функция "Формирование накладных по календарному плану  договора" формирует  расходные
   накладные с учетом выполнения календарного плана договора  из ДО.  А именно,  определяется
   ПКП,  в  период  действия которого  попадает данная  отгрузка. рассчитывается  количество,
   которое осталось отгрузить до полного выполнения данного ПКП (по  накладным привязанным  к
   ПКП).  Если  в ДО  количество МЦ  не превышает  неотгруженного по  ПКП количества,  то
   формируется одна накладная по ДО с привязкой к данному ПКП. Если количество в ДО превышает
   неотгруженное  по  ПКП  количество,  то  формируется  накладная  на  неотгруженное по  ПКП
   количество (накладная привязывается к этому  ПКП), а  далее повторяется  этот же  процесс,
   только уже со следующим ПКП и так пока не будут сформированы накладные  на все  количество
   из ДО. Если по всем ПКП МЦ распределены, а в ДО осталась нераспределенная  спецификация,
   На весь  остаток формируется  накладная без  привязки к  ПКП (только  переносится связь  с
   договором/соглашением из ДО).

Параметры:
  pNRec - ссылка на ДО
#end

//******************************************************************************

Interface MakeRaspByDOG;

#include DOfuns.var
#include SDfuns.var

//распределение в разрезе ДОГОВОР - ПЛАН
Table STRUCT TmpDogRasp "Договора в распределении"
(
  NRec        : comp,
  cDog        : comp   "ссылка на договор",
  cAppDog     : comp   "ссылка на доп.соглашение",
  cPlan       : comp   "ссылка на ПКП"
)
With Index
(
  TmpDogRasp01 = NRec (Surrogate, Unique),
  TmpDogRasp02 = cDog + cAppDog + cPlan,
  TmpDogRasp03 = cDog + cPlan
);

//Спецификация накладных
Table STRUCT TmpMCRasp "Распределение МЦ"
(
  cSpStep     : comp   "ссылка на спецификацию",
  cDogRasp    : comp   "ссылка на TmpDogRasp",
  cMC         : comp   "ссылка на матценность",
  cPodr       : comp   "ссылка на подразделение",
  KolUth      : double "Количество в учетных единицах",
  KolPlan     : double "кол-во по ПКП, уч.ед.",
  KolOrd      : double "Суммарное кол-во по накладным, уч.ед.",
  KolOrd2     : double "Для протокола",
  KolRasp     : double "Потребность в кол-ве, уч.ед.",
  Kol         : double "К-во в отп.ед., с учетом округления",
  dMin        : date   "Нач. дата отгрузки по всем ПКП",
  dMax        : date   "Кон. дата отгрузки по всем ПКП",
  dInput      : date   "Дата ввода договора,ПКП"
)
With Index
(
  TmpMCRasp01 = cSpStep + cPodr + cDogRasp,
  TmpMCRasp02 = cPodr + cMC + cDogRasp,
  TmpMCRasp03 = cDogRasp + cMC,
  TmpMCRasp04 = cMC + cPodr + dInput,
  TmpMCRasp05 = cSpStep + cDogRasp //для протокола
);

Table STRUCT TmpMCKol "Количество МЦ"
(
  cMC         : comp   "ссылка на матценность",
  cDogRasp    : comp   "ccылка на разрез",
  KolRasp     : double "Распред. кол-во  по МЦ"
)
With Index
(
  TmpMCKol01 = cMC + cDogRasp
);

Table STRUCT TmpListDog "распределенные договора,согл."
(
  cDog    : comp "ссылка на договор",
  cSpStep : comp "ссыкла на спецификацию"
)
With Index
(
  TmpListDog01 = cDog + cSpStep
);

Table STRUCT TmpListPlan "распределенные ПКП"
(
  cPlan   : comp "ссылка на ПКП",
  cSpStep : comp "ссыкла на спецификацию"
)
With Index
(
  TmpListPlan01 = cPlan + cSpStep
);

Table STRUCT TmpProtKol "кол-во для протокола"
(
  cSopr   : comp "ссылка на накладную",
  cSpSopr : comp "ссыкла на спецификацию",
  KolPlan : double "кол-во по плану",
  KolOrd  : double "кол-во в ордерах"
)
With Index
(
  TmpProtKol01 = cSopr + cSpSopr
);

create view
var
   pNRec    : comp;    //ДО
   pDog     : comp;    //ссылка на договор
   pSpStep  : comp;
   pCurDogRasp : comp; //ссылка на текущий разрез

   _dRasp   : date;    //дата проверки периода договора(ПКП)
   e        : double;  //точность в количестве
   iNaklCount: integer; //кол-во накладных (для визуализации)

from
   KatSopr, SpSopr,
   SDocBuf, SpDocBuf,
   SpDocBuf_Ex,
   Synonym KatSopr KatSopr2,

   BaseDoc, StepDoc,
   SpStep (SpStep02),

   Dogovor,
   Synonym Dogovor Dogovor2,
   CalPlan,
   IerDog,
   IerCalPl,

   SpDocs,
   Synonym SpDocs SpDocs2,
   KatOtpEd,
   Synonym KatOtpEd KatOtpEd2,
   Synonym KatOtpEd KatOtpEdDocs,

   KatPodr,
   SklOrder,
   SpOrder,

   TmpMCRasp,
   TmpDogRasp,
   TmpProtKol,
   TmpMCKol,
   TmpListPlan,
   TmpListDog,

   SpGrSch

where
((
   pNRec             ==  BaseDoc.NRec       and
   BaseDoc.Nrec      ==  StepDoc.cBaseDoc   and
   StepDoc.Nrec      ==  SpStep.cStepDoc    and
   word(1)           ==  SpStep.PrMC (noindex) and
   SpStep.cOtpEd     ==  KatOtpEd.NRec      and
   SpStep.cMCUsl     ==  KatMC.NRec         and
   KatMC.cEd         ==  KatEd.NRec         and

   StepDoc.NRec      ==  KatSopr.cStepDoc   and
   word(201)         ==  KatSopr.VidSopr    and
//   SpStep.NRec       ==  SpSopr.cSpStep     and //?!!
//   KatSopr.Nrec      ==  SpSopr.cSopr       and

   pDog              ==  Dogovor2.nRec      and
   Dogovor2.nRec     ==  IerDog.cUpRec      and
   word(1)           ==  IerDog.IsLeaf      and
   IerDog.cRec       ==  Dogovor.NRec       and
   Dogovor.NRec      ==  IerCalPl.cDogovor  and
   word(1)           ==  IerCalPl.IsLeaf    and
   IerCalPl.cRec     ==  CalPlan.nRec       and


   CalPlan.cOrg      ==  KatOrg.nRec        and
   word(403)         ==  SpDocs.TiDk        and //ПКП
   CalPlan.nRec      ==  SpDocs.cDoc        and
   SpDocs.cOtpEd     ==  KatOtpEdDocs.Nrec  and

   Dogovor2.cDopKlas ==  KatPodr.NRec           //привязка склада к верхнему уровню договоров
))

bounds  SpecifDog   = Dogovor.TiDk   ==  SpDocs2.TiDk  and
                      Dogovor.Nrec   ==  SpDocs2.cDoc

bounds  SpecifDog2  = SpDocs2.cOtpEd  ==  KatOtpEd2.NRec

bounds  _TmpMCRasp  = pSpStep          ==  TmpMCRasp.cSpStep   and
                      KatPodr.NRec     ==  TmpMCRasp.cPodr     and
                      TmpDogRasp.NRec  ==  TmpMCRasp.cDogRasp

bounds _TmpDogRasp  = pCurDogRasp      ==  TmpDogRasp.NRec
;

Parameters
  pNrec;

Form frmProt('rasp_err.out','ERRR') with novisual;
Form frmRasp('raspDog.out','RaspDog') with novisual;

#include do2bufer.vpp
//общие функции распределения
#include RaspDog.vpp

//проверка привязки подразделений
function CheckPodrInDg (aGrDog : comp; var sError: string) : boolean;
begin

  CheckPodrInDg := false;

  if GetFirst SpGrSch where (( aGrDog  ==  SpGrSch.cGroupSch  and
                               word(1) ==  SpGrSch.wList      and
                               pDog    ==  SpGrSch.cBaseDoc       )) = tsOk
     if (Dogovor2.Status = 1) and (Dogovor2.cDogovor = 0)
       if GetFirst KatPodr = tsOk
       {
         CheckPodrInDg := true;
         set BaseDoc.cSklad := KatPodr.NRec;
         Update Current BaseDoc;
       }
       else
         sError := ' - к договору не привязан склад';
     else
       sError := ' - договор не в статусе "исполняемый"';
  else
    sError := ' - договор не относится к группе VIP-договоров';
end;

//расчет общего кол-ва для каждой МЦ спецификации в учетных единицах
function PreparKolSpecif : integer;
var
  i : integer;
begin

  ResetBounds(tnTmpMCRasp);
  delete all TmpMCRasp;
  SetBounds(tnTmpMCRasp);

  ResetBounds(tnTmpDogRasp);
  delete all TmpDogRasp;
  SetBounds(tnTmpDogRasp);

  delete all  TmpMCKol;

  pCurDogRasp := comp(0);

  i := 0;
  _Loop SpStep
  {
    i := i + 1;
  }//_Loop

  PreparKolSpecif := i;

end;

//распределенные планы
function CheckPlan(aPlan,aRec: comp): boolean;
{
  if GetFirst TmpListPlan where ((aPlan == TmpListPlan.cPlan and
                                  aRec  == TmpListPlan.cSpStep )) = tsOk
    CheckPlan := false
  else
  {
    CheckPlan := true;
    TmpListPlan.cPlan   := aPlan;
    TmpListPlan.cSpStep := aRec;
    insert current TmpListPlan;
  }
}

//распределенные договора
function CheckDog(aDog,aRec: comp): boolean;
{
  if GetFirst TmpListDog where ((aDog == TmpListDog.cDog and
                                 aRec == TmpListDog.cSpStep)) = tsOk
    CheckDog := false
  else
  {
    CheckDog := true;
    TmpListDog.cDog    := aDog;
    TmpListDog.cSpStep := aRec;
    insert current TmpListDog;
  }
}

//расчет оприходованного количества для каждой МЦ спецификации ДО
//за период действия ПКП
//для тек.договора
function CalcKolInOrder (aMC : comp) : boolean;
var
  tKol : double;
begin
  CalcKolInOrder := true;

  if (GetFirst Dogovor2 = tsOk)
   if (Dogovor2.Status = 1) and (Dogovor2.cDogovor = 0)
    if (GetFirst KatPodr = tsOk)
    {
      ResetBounds(#TmpDogRasp);
      _Loop TmpDogRasp
       if (GetFirst TmpMCRasp = tsOk)
       {
         tKol := double(0);
         _Loop KatSopr2 where ((TmpDogRasp.cDog    == KatSopr2.cDogovor     and
                                TmpDogRasp.cAppDog == KatSopr2.cAppDogovor  and
                                TmpDogRasp.cPlan   == KatSopr2.cCalPlan     ))
           _Loop SklOrder where ((KatSopr2.NRec == SklOrder.cSopr))
           if (SklOrder.VidOrder = 1) and //расходный
              (SklOrder.SP       = 0)     //склад

//            if (TmpMCRasp.dMin <= SklOrder.dOrd) and
//               (TmpMCRasp.dMax >= SklOrder.dOrd)
// в расчет принимаются все ордера, связанные с накладной
            {
              _Loop SpOrder where (( SklOrder.NRec  ==  SpOrder.cSklOrder  and
                                     aMC            ==  SpOrder.cMC        ))
                tKol := tKol + SpOrder.Kol;
            }
         TmpMCRasp.KolOrd  := tKol;
         TmpMCRasp.KolOrd2 := tKol;
         update current TmpMCRasp;
       }
       SetBounds(#TmpDogRasp);
    }
end;


//расчет планируемого кол-ва в соответствии с ПКП для текущей МЦ спецификации ДО
//на период действия ПКП в учетных единицах измерения
//для тек. договора
function CalcKolInCalPlan (aMC : comp) : boolean;
var
  tKol,koefp : double;
begin

  CalcKolInCalPlan := true;
  AddBounds  (tbSpecifDog);
  AddBounds  (tbSpecifDog2);

   //заполнение TmpMCRasp данными из договоров и подсчет уже распределенного кол-ва
   //текущим распределением
  if (GetFirst Dogovor2 = tsOk)
   if (Dogovor2.Status = 1) and (Dogovor2.cDogovor = 0)
    if GetFirst KatPodr = tsOk
    {
      //подсчет кол-ва в разрезе СКЛАД-ПЛАН
      _Loop IerDog
       if Dogovor.Status = 1
        if GetFirst IerCalPl = tsOk  //подсчет по ПКП
        {
         _Loop IerCalPl
          if (IerCalPl.cUpRec = IerCalPl.cRec)
           if CalPlan.Status = 1
            if (CalPlan.dFrom <= _dRasp)
             if (CalPlan.DtO  >= _dRasp)
              if CheckPlan(CalPlan.NRec,SpStep.NRec)
              {
               tKol := double(0);
               _Loop SpDocs
                if SpDocs.Direct = 1
                 if SpDocs.cMcUsl = aMC
                 {
                   koefp := 1;
                   if SpDocs.cOtpEd <> 0 koefp := KatOtpEdDocs.koef;
                   tKol := tKol + SpDocs.Kol*koefp;
                 }
               if tKol > double(0)
               {
                 GetTmpDogRasp(Dogovor2.NRec,
                               if(Dogovor.cDogovor=0,comp(0),Dogovor.NRec),
                               CalPlan.NRec
                              );
                 InsTmpMcRasp(aMC, CalPlan.dInput);

                 if CalPlan.dFrom < TmpMCRasp.dMin
                   TmpMCRasp.dMin := CalPlan.dFrom;

                 if CalPlan.DtO > TmpMCRasp.dMax
                   TmpMCRasp.dMax := CalPlan.DtO;

                 TmpMCRasp.KolPlan := TmpMCRasp.KolPlan + tKol;
                 update current TmpMCRasp;
               }
              }
        }
        // подсчет кол-ва в разрезе СКЛАД - ДОГОВОР (СОЛГЛАШЕНИЕ)
        else  //подсчет по договору или соглашению
        {
         if (Dogovor.DBEG <= _dRasp)
          if (Dogovor.DEND >= _dRasp)
           if CheckDog(Dogovor.NRec,SpStep.NRec)
           {
             tKol := double(0);
             _Loop SpDocs2
              if SpDocs2.Direct = 1
               if SpDocs2.cMcUsl = aMC
               {
                 koefp := 1;
                 if SpDocs2.cOtpEd <> 0 koefp := KatOtpEd2.koef;
                 tKol := tKol + SpDocs2.Kol*koefp;
               }

             if tKol > double(0)
             {
               GetTmpDogRasp(Dogovor2.NRec,
                             if(Dogovor.cDogovor=0,comp(0),Dogovor.NRec),
                             comp(0));
               InsTmpMcRasp(aMC, Dogovor.dInput);

               if Dogovor.DBEG < TmpMCRasp.dMin
                  TmpMCRasp.dMin := Dogovor.DBEG;

               if Dogovor.DEND > TmpMCRasp.dMax
                  TmpMCRasp.dMax := Dogovor.DEND;

               TmpMCRasp.KolPlan := TmpMCRasp.KolPlan + tKol;
               update current TmpMCRasp;
             }
           }

        }

     }
     else CalcKolInCalPlan := false;

  SubBounds(tbSpecifDog2);
  SubBounds(tbSpecifDog);

end;

//расчет недопоставленного кол-ва для текущей МЦ спецификации накладной в соответствии с ПКП
//в учетных единицах измерения
function CalcKolUth (aGrDog : comp) : boolean;
begin
    CalcKolUth := true;

    pSpStep := SpStep.NRec;

    if not CalcKolInCalPlan(SpStep.cMCUsl)
       CalcKolUth := false;

    if not CalcKolInOrder(SpStep.cMCUsl)
       CalcKolUth := false;
end;

//Вставка накладных
Procedure InsertAllNakl;
var
  pMakeSoprByBuff: MakeSoprByBuff;
  res: word;
  tRec: comp;
{
  // это чтобы не показывалось распределение по складам
  SaveMyDsk(word(0),'ShowRaspr');
  // чтобы курс запрашивался
  SaveMyDsk (false, 'MakeSoprByBuff_GetCurse');

   StartNewVisual(vtIndicatorVisual,vfTimer,'Формирование накладных',RecordsInTable(#TmpDogRasp));
  _loop TmpDogRasp
  {
     delete all SDocBuf;
     delete all SpDocBuf;
     FillNaklBuffer;
     SDocBuf.cDogovor    := TmpDogRasp.cDog;
     SDocBuf.cAppDogovor := TmpDogRasp.cAppDog;
     SDocBuf.cCalPlan    := TmpDogRasp.cPlan;
     Update current SDocBuf;

     _Loop TmpMCRasp where ((TmpDogRasp.NRec == TmpMCRasp.cDogRasp))
       if GetFirst SpStep where ((TmpMCRasp.cSpStep == SpStep.NRec)) = tsOk
     {
       FillSpNaklBuffer;
       SpDocBuf.KolSkl  := TmpMCRasp.Kol;
       SpDocBuf.KolFact := TmpMCRasp.Kol;
       Update current SpDocBuf;
     }

     SaveMyDsk(word(13),'RaspVIPDog');
     res := pMakeSoprByBuff.MakeDocument(BaseDoc.dDoc,frmProt.Handle,SDocBuf.Name,word(1));
     NextVisual;
     if (res = 0)
     {
       iNaklCount := iNaklCount + 1;
       ReadMyDsk(tRec,'RaspVIPDogNRec',false);
      //установка склада,номера
      if GetFirst KatSopr where ((tRec == KatSopr.NRec)) = tsOk
      {
        KatSopr.NSopr     := BaseDoc.NoDoc + '_' + lpadch(string(iNaklCount),'0',3);
        if GetFirst TmpMCRasp where ((TmpDogRasp.NRec == TmpMCRasp.cDogRasp)) = tsOk
          KatSopr.cPodrFrom := TmpMCRasp.cPodr;
        update current KatSopr;
      }
     }
  }

  StopVisual('',0);
}

//сохранение остатка по тек. позиции
procedure SaveOstKol (aMC,aDogRasp : comp; aKol : double);
begin
    if GetFirst TmpMCKol
       where (( aMC      ==  TmpMCKol.cMC  and
                aDogRasp ==  TmpMCKol.cDogRasp )) = tsOk
    {
       TmpMCKol.KolRasp := TmpMCKol.KolRasp + aKol;
       update current TmpMCKol;
    }
    else
    {
      ClearBuffer(tnTmpMCKol);
      TmpMCKol.cMC      := aMC;
      TmpMCKol.cDogRasp := aDogRasp;
      TmpMCKol.KolRasp  := aKol;
      insert current TmpMCKol;
    }

end;

function GetOstKol (aMC,aDogRasp : comp) : double;
begin
    GetOstKol := comp(0);
    if GetFirst TmpMCKol
       where (( aMC      ==  TmpMCKol.cMC  and
                aDogRasp ==  TmpMCKol.cDogRasp )) = tsOk
    {
       GetOstKol := TmpMCKol.KolRasp;
    }
end;

//Распределение по складам в процентном отношении ПКП и спецификации
procedure  FillRasp;
var
  //все в уч.единицах по одной позиции накладной
  tAllKol, //общее кол-во к распределению по всем складам
  tKol,    //распределенное кол-во по одному складу
  tKolOst, //остаток превышения кол-ва по плану
  tKolUth, //нераспределенное кол-во
  Koefp    //коэффициэнт пересчета из учетных в отпускные
  : double;
begin

  _Loop SpStep
  {
    tAllKol := double(0);

    _Loop TmpMCRasp ordered by index TmpMCRasp04
    if SpStep.NRec = TmpMCRasp.cSpStep
    {
      TmpMCRasp.KolOrd := TmpMCRasp.KolOrd +
                 GetOstKol(TmpMCRasp.cMC,TmpMCRasp.cDogRasp);//остаток текущего распределения

      TmpMCRasp.KolRasp := TmpMCRasp.KolPlan - TmpMCRasp.KolOrd;

      if TmpMCRasp.KolRasp < 0
         TmpMCRasp.KolRasp := 0;
      Update Current TmpMCRasp;

      tAllKol := tAllKol + TmpMCRasp.KolRasp;

    }

    if tAllKol > double(0)
     if GetFirst TmpMCRasp
           where ((SpStep.NRec == TmpMCRasp.cSpStep)) = tsOk
     {
       tKolUth := TmpMCRasp.KolUth;

      _LOOP TmpMCRasp ordered by index TmpMCRasp04
       if SpStep.NRec = TmpMCRasp.cSpStep
       {
         tKol  := TmpMCRasp.KolRasp;

         if KatEd.Diskret = 1   //округление для дискретных уч.единиц
         {
            tKol    := Round(tKol);
         }

         //контроль превышения кол-ва в позиции накладной
         if tKol > tKolUth
          if KatEd.Diskret = 1   //округление для дискретных уч.единиц
             tKol := trunc(tKolUth);
          else
             tKol := tKolUth;

         //распределено в уч.ед.
         tKolOst := tKol;

         Koefp := 1;
         if SpStep.cOtpEd <> comp(0) koefp := KatOtpEd.koef;

         //округление отпускных единиц
         if KatOtpEd.Diskret = 1
         {
           TmpMCRasp.Kol := Round(tKol/koefp);
           tKol    := TmpMCRasp.Kol*koefp;
         }
         else
         {
           TmpMCRasp.Kol := tKol/koefp;
         }

         //вычесть распределеное
         tAllKol := tAllKol - TmpMCRasp.KolRasp;
         tKolUth := tKolUth - tKol;
         Update Current TmpMCRasp;

         SaveOstKol (TmpMCRasp.cMC, TmpMCRasp.cDogRasp, tKolOst);
       }//_loop TmpMCRasp
     }
  }//_loop
end;

//формирование накладной на нераспределенное кол-во
Procedure InsertNotRasp;
var
  pMakeSoprByBuff: MakeSoprByBuff;
  res : word;
  tRec: comp;
  tKol: double;
  bMake: boolean;
begin
  // это чтобы не показывалось распределение по складам
  SaveMyDsk(word(0),'ShowRaspr');

  StartNewVisual(vtIndicatorVisual,vfTimer,'Формирование накладной по остаткам',1);

  delete all SDocBuf;
  delete all SpDocBuf;

  FillNaklBuffer;
  SDocBuf.cDogovor    := Dogovor2.NRec;
  Update current SDocBuf;

  NextVisual;

  bMake := false;
  _Loop SpStep
  {
    tKol := KolInSpSopr(SpStep.NRec,1);
    if (SpStep.KolSkl - tKol > e)
    {
       tKol := SpStep.KolSkl - tKol;

       FillSpNaklBuffer;

       SpDocBuf.KolSkl  := tKol;
       SpDocBuf.KolFact := tKol;
       Update current SpDocBuf;
       bMake := true;
    }

  }

  if (not bMake)
  {
    StopVisual('',0);
    EXIT;
  }

  SaveMyDsk(word(13),'RaspVIPDog');
  res := pMakeSoprByBuff.MakeDocument(BaseDoc.dDoc,frmProt.Handle,SDocBuf.Name,word(1));

  if (res = 0)
  {
    ReadMyDsk(tRec,'RaspVIPDogNRec',false);
    //установка склада,номера
    if GetFirst KatSopr where ((tRec == KatSopr.NRec)) = tsOk
    {
      KatSopr.NSopr     := BaseDoc.NoDoc + '_' + lpadch(string(0),'0',3);
      KatSopr.cPodrFrom := KatPodr.NRec;
      update current KatSopr;
    }
    iNaklCount := iNaklCount + 1;
  }
  StopVisual('',0);
end;

//Запуск распределения на дату
Function AddRasp: boolean;
var
  iCount : integer;
  bError : boolean;
{
   AddRasp := false;
   bError  := false;

   iCount := PreparKolSpecif;

   //подсчет количества
   AddBounds(tb_TmpDogRasp);
   AddBounds(tb_TmpMCRasp);
   StartNewVisual(vtIndicatorVisual,vfTimer,'Распределение по складам на '+string(_dRasp),iCount);
   _Loop SpStep
   {
     if not CalcKolUth(coGetTune('Dog.GrVipDog'))
     {
       message('Ошибки в расчете количества');
       bError := true;
       break;
     }
     NextVisual;
   }
   SubBounds(tb_TmpMCRasp);
   SubBounds(tb_TmpDogRasp);

   //распределение
   if not bError FillRasp;
   StopVisual('Распределение завершено.',0);

   //формирование накладных
   InsertAllNakl;

   //проверка - все ли распределено
   _Loop SpStep
   {
     if abs(SpStep.KolSkl - KolInSpSopr(SpStep.NRec, 1)) > e
     {
       AddRasp := true;
       break;
     }
   }
   //сохранение информации по кол-ву (для протокола)
   SaveProtKol;
}

Handleevent
cmInit:
{
  abort;

  if wGetTune('Dog.DopKlas') <> cgKau_KatPodr
  {
      message('Необходимо установить значение настройки'#10#13 +
              'ОПЕРАТИВНЫЙ КОНТУР -> УПРАВЛЕНИЕ ДОГОВОРАМИ ->'#10#13 +
              'ДОПОЛНИТЕЛЬНАЯ КЛАССИФИКАЦИЯ ДОГОВОРОВ'#10#13 +
              'в значение: "Подразделения"!'  ) ;
      exit;
  }

  if GetFirst SpStep <> tsOk
  {
    message('Нет спецификации...');
    exit;
  }

  //проверка ДО на наличие накладных
  if not CheckNakl
  {
     Message('У данного ДО есть накладные.'#10#13+
             'Формирование отменено.');
     exit;
  }

  if (RunInterface('GetSomeDogovor',
                           word(0),            // pVidDog,    // вид документа - если задан будет установлен фильтр
                           word(0FFFFh),       // pStatus,    // 0-все документы, иначе маска РАЗРЕШЕННЫХ статусов
                           word(0),            // pDirect,    // 0-все документы, 1-продажа, 2-закупка
                           word(0),            // pAttach,    // 0-выбирать соглашения нельзя, 1-можно, 2-только соглашения
                           false,              // OkOne,      // TRUE - груповой выбор FALSE - только один
                           pDog,               // prmDogovor, // возвращаемый указатель на договор
                           false,              //true,               // OneLevel,   // показывать записи одного уровня (true), false - нет
                           comp(0)             // pOwn        // ссылка на владельца уровня (действует если OneLevel = true) - ВОЗВРАЩАЕМЫЙ!
                    ) = cmCancel)
  {
    message('Не выбран договор.'#10#13+'Формирование отменено.');
    Exit;
  }
  else
  {
    set pDog := pDog;
    var sError: string;
    if not CheckPodrInDg (coGetTune('Dog.GrVipDog'), sError)
    {
      Message('По выбранному договору не могут быть сформированы накладные:'#10#13+sError);
      exit;
    }
  }

  var isOst: boolean;
  e := doGetTune('Oper.MinKolMC');

  _dRasp := BaseDoc.dDoc;
  delete all TmpListPlan;
  delete all TmpListDog;
  delete all TmpProtKol;

  iNaklCount := 0;

  DO
  {
    isOst := AddRasp;
    if isOst
    {
      case wGetTune('Doc.Buy.ReRaspMC') of
       0: isOst := false; //остаток пойдет на выбранный склад
       1: if Message('Остались нераспределенные матценности.'#10#13 +
                     'Распределить остаток на '+
                     string(Add_Months(_dRasp, 1))+'?', YesNo + Confirmation) = cmYes
            _dRasp := Add_Months(_dRasp, 1)
          else
            isOst := false;

       2: if RunDialog('GetDateRasp',_dRasp) = cmCancel
            isOst := false
      end;

      //формирование накладной на нераспределенное кол-во
      if not isOst
        InsertNotRasp;
    }
  }
  WHILE isOst;

  BaseDoc.cDogovor := Dogovor2.NRec;
  Update Current BaseDoc;

  message('Формирование накладных по завершено');

  //протокол формирования
  PrintRasp;

}

end;
End.
