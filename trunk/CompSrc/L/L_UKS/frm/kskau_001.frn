.create view KolSpSopr
var
  pNrec: comp;
  wPrMc: word;
from
  KatSopr,
  SpSopr  (SPSOPR11),
  KatMc,
  KatUsl,
  KatParty,
  KatOtpEd,
  KatEd
where
((
     pNrec          ==  SpSopr.cSopr
AND  word(1)        <<  SpSopr.PrMc
AND  SpSopr.cMCUSL  ==  KatMC.NRec
AND  SpSopr.cMCUSL  ==  KatUsl.NRec
AND  SpSopr.cOtpEd  ==  KatOtpEd.NRec
AND  SpSopr.cParty == KatParty.NRec
AND  if (SpSopr.PrMc = 1,
         KatMc.cEd,
         KatUsl.cEd)  == KatEd.NRec
))

;
!Форматирование строки мемо-поля
.function KolInStrMem(var Str: string; var StartPos: word; LengthStr: word; UpdateStr: boolean): word;
var
  iLine, KolSpace:byte;
  TempStr : string;
!Первый параметр - поле, второй параметр - стартовая позиция
!Третий длинна поля (в RTF- формате использовать шрифт Courier New)
!Четвертый параметр - изменяить или нет Str
!Ставит пробел в строке Str ч.з. каждые LtngthStr+1 символов (при печати этот пробел 'съедается' редактором
Begin

  TempStr  := Str;
  KolSpace := 0;

  if (StartPos > 0)
    Str := ' ' + Str;

  if (Length(Str) > LengthStr - StartPos)
  {
    iLine := LengthStr - StartPos + 1;

    do
    {
      if (SubStr(Str, iLine, 1) <> ' ')
        Str := SubStr(Str, 1, iLine - 1) + ' ' + SubStr(Str, iLine, Length(Str));

      KolSpace := KolSpace + 1;//подсчитаем к-во пробелов
      iLine := iLine + LengthStr + 1;
    }
    while Length(Str) >= iLine //ставит в конце каждой строке пробел

!length(str) >iLine - можно написать и так,тогда последнее слово в строке
!будет переходить на новую строку. Это не повлияет на подсчет строк...
    StartPos := (StartPos + Length(Str) - 1) Mod LengthStr;
  }
  else
  {
    StartPos := Length(Str);
  }

  KolInStrMem := KolSpace;// к-во строк в наим. МЦ

  if (NOT UpdateStr)
    Str := TempStr;

end.
