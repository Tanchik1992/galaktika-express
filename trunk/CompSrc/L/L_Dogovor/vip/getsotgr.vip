/*
 ╔═══════════════════════════════════════════════════════════════════════════╗
 ║                     (c) 1987,98 корпорация ГАЛАКТИКА                      ║
 ║ Проект        : ГАЛАКТИКА                                                 ║
 ║ Система       : Оперативный контур                                        ║
 ║ Версия        : 5.70                                                      ║
 ║ Назначение    : Групповой выбор распоряжений на отгрузку                  ║
 ║ Ответственный : Глушаков Дмитрий Сергеевич                                ║
 ║ Параметры     : есть                                                      ║
 ║    pStatus     // 0 - выбирать все, иначе битовая маска запрещенных       ║
 ║    OkOne       // TRUE-груповой выбор, FALSE-только один                  ║
 ║    prmOtgOrder // возвращаемый указатель на распоряжение на отгрузку      ║
 ║    OneLevel    // показывать записи одного уровня-true, false- нет        ║
 ║    pOwn        // ссылка на влдельца уровня(действует если OneLevel=true) ║
 ╚═══════════════════════════════════════════════════════════════════════════╝
*/

#doc
Интерфейс выбора распоряжений на отгрузку
#end
Interface GetGrOtgOrder 'Выбор распоряжений на отгрузку'
  EscClose,
  Cyan,
  DoAccept;

Create View
Var
//--параметры
  pStatus      : word;
  OkOne        : boolean;
  prmOtgOrder  : comp;
  OneLevel     : boolean;
  pOwn         : Comp;
//--
  Node         : comp;
  MarkerOtg    : longint;
  IndexOtg     : longint;
  isTreeFormat : boolean; // признак в каком виде интерфейс true-дерево,false-brows
  (
  picked,
  OtgOrderStatus       // 1
  )
As Select
  if(OkOne,
     if(SearchMarker(MarkerOtg,OtgOrder.NRec,IndexOtg),
        '[√] '+OtgOrder.Descr,
        '  '+OtgOrder.Descr),
     OtgOrder.Descr),
  // 1
  if ( OtgOrder.Status = 0,   'оформляемый',
    if ( OtgOrder.Status = 1, 'исполняемый',
    if ( OtgOrder.Status = 2, 'отмененный',
    if ( OtgOrder.Status = 3, 'закрытый',
    '!некорр!'))))
From
  OtgOrder
Where
  ((
      Node == OtgOrder.cOwner
  ))
;

Parameters
  pStatus,     // 0 - выбирать все документы, иначе битовая маска запрещенных статусов документов
  OkOne,       // TRUE - груповой выбор FALSE - только один
  prmOtgOrder, // возвращаемый указатель на распоряжение на отгрузку
  OneLevel,    // показывать записи одного уровня (true), false - нет
  pOwn         // ссылка на владельца уровня(действует если OneLevel = true)
  ;

//-- Установить заголовок окна
Procedure SetMyTitle;
  {
  if (OkOne)
    SetTitle('Групповой выбор распоряжений на отгрузку (помечено: ' + string(GetMarkerCount(MarkerOtg)) + ')');
  else
    SetTitle('Выбор распоряжения на отгрузку');
  }

//-- Отменить выделение
Procedure KillPick;
  {
  ClearMarker(MarkerOtg);
  SetMyTitle;
  }

#include accesden.vpp

//-- пометить одну позицию
function OneMarkPick (ShowMess:boolean) : boolean;
  {
  OneMarkPick := false;
  if ItemAccessDenided (pStatus,OtgOrder.Status)
    {
    if (ShowMess)
      message('Нельзя пометить распоряжение на отгрузку с данным статусом !');
    EXIT;
    }
  InsertMarker(MarkerOtg,OtgOrder.NRec);
  OneMarkPick := true;
  }

!------------------------------------------------------------------------------
Panel panOtgOrder;
 Table OtgOrder;
Tree trOtgOrder (,,);
Fields
  picked          'Дескр.'     ('Дескриптор(идентификатор) пользователя',,)    : [7], protect,
    {Font = {Color = if (picked='[√] '+OtgOrder.Descr,ColorMark,0) }};
  OtgOrder.NoDoc  'Номер'      ('Номер документа',,)         : [10], protect,
    {Font = {Color = if (picked='[√] '+OtgOrder.Descr,ColorMark,0) }};
  OtgOrder.dDoc   'Дата док.'  ('Дата документа',,)          : [10,'DD/MM/YYYY'], protect,
    {Font = {Color = if (picked='[√] '+OtgOrder.Descr,ColorMark,0) }};
  OtgOrder.dFrom  'Действ. с'  ('Дата начала действия',,)    : [10,'DD/MM/YYYY'], protect,
    {Font = {Color = if (picked='[√] '+OtgOrder.Descr,ColorMark,0) }};
  OtgOrder.dTo    'Действ. по' ('Дата окончания действия',,) : [10,'DD/MM/YYYY'], protect,
    {Font = {Color = if (picked='[√] '+OtgOrder.Descr,ColorMark,0) }};
  OtgOrderStatus  'Статус'     ('Статус документа',,)        : [10], protect,
    {Font = {Color = if (picked='[√] '+OtgOrder.Descr,ColorMark,0) }};
end;

Browse brOtgOrder (,,);
Fields
  picked          'Дескр.'     ('Дескриптор(идентификатор) пользователя',,)    : [7], protect,
    {Font = {Color = if (picked='[√] '+OtgOrder.Descr,ColorMark,0) }};
  OtgOrder.NoDoc  'Номер'      ('Номер документа',,)         : [10], protect,
    {Font = {Color = if (picked='[√] '+OtgOrder.Descr,ColorMark,0) }};
  OtgOrder.dDoc   'Дата док.'  ('Дата документа',,)          : [10,'DD/MM/YYYY'], protect,
    {Font = {Color = if (picked='[√] '+OtgOrder.Descr,ColorMark,0) }};
  OtgOrder.dFrom  'Действ. с'  ('Дата начала действия',,)    : [10,'DD/MM/YYYY'], protect,
    {Font = {Color = if (picked='[√] '+OtgOrder.Descr,ColorMark,0) }};
  OtgOrder.dTo    'Действ. по' ('Дата окончания действия',,) : [10,'DD/MM/YYYY'], protect,
    {Font = {Color = if (picked='[√] '+OtgOrder.Descr,ColorMark,0) }};
  OtgOrderStatus  'Статус'     ('Статус документа',,)        : [10], protect,
    {Font = {Color = if (picked='[√] '+OtgOrder.Descr,ColorMark,0) }};
end;
!------------------------------------------------------------------------------
procedure SetMyFormat;
  {
  isTreeFormat := true;
  SetHelpAndStatusContext(trOtgOrder,-1,
                          if (OkOne,sci1EnInsTree,sci1EnEscTree),
                          0);
  SetHelpAndStatusContext(brOtgOrder,-1,
                          if (OkOne,sci1EnIns,sci1EnEsc),
                          0);
  if (OneLevel = false)   // показывать записи всех уровней
    SetFormat(trOtgOrder)
  else
    {
    Node := pOwn;
    isTreeFormat := false;
    SetFormat(brOtgOrder);
    }
  SetMyTitle;
  }

//--  Пометить группу
procedure MarkGroup;
var LevelClosed: boolean;
    n          : word;
    i          : word;
    SaveNrec   : Comp;
  {
  OneMarkPick(false);
  if TreeCloseNode(trOtgOrder)
    LevelClosed:=true;
  else
    LevelClosed:=false;
  PushPos(#OtgOrder);
  n:=0;
  if TreeGetNext(trOtgOrder)
    {
    SaveNrec := OtgOrder.NRec;
    TreeGetPrev(trOtgOrder);
    }
  if TreeOpenNode(trOtgOrder)
    {
    n:=n+1;
    PushPos(#OtgOrder);
    }
  if TreeGetNext(trOtgOrder)
    do
      {
      if (OtgOrder.NRec = SaveNrec)
        Break;
      OneMarkPick(false);
      if TreeOpenNode(trOtgOrder)
        {
        n:=n+1;
        PushPos(#OtgOrder);
        }
      }
    while TreeGetNext(trOtgOrder);
  FOR ( i:=1; i<=n; i:=i+1)
    {
    PopPos(#OtgOrder);
    TreeCloseNode(trOtgOrder);
    }
  PopPos(#OtgOrder);
  if (LevelClosed)
    TreeOpenNode(trOtgOrder);
  TreeJumpToRecord (trOtgOrder,OtgOrder.nRec);
  RescanPanel(#OtgOrder);
}

//--  Отменить пометку группы
procedure UnMarkGroup;
var LevelClosed: boolean;
    n          : word;
    i          : word;
    SaveNrec   : Comp;
  {
  DeleteMarker(MarkerOtg,OtgOrder.NRec);
  if TreeCloseNode(trOtgOrder)
    LevelClosed:=true;
  else
    LevelClosed:=false
  PushPos(#OtgOrder);
  n:=0;
  if TreeGetNext(trOtgOrder)
    {
    SaveNrec := OtgOrder.NRec;
    TreeGetPrev(trOtgOrder);
    }
  if TreeOpenNode(trOtgOrder)
    {
    n:=n+1;
    PushPos(#OtgOrder);
    }
  if TreeGetNext(trOtgOrder)
    do
      {
      if (OtgOrder.NRec = SaveNrec)
        Break;
      DeleteMarker(MarkerOtg,OtgOrder.NRec);
      if TreeOpenNode(trOtgOrder)
        {
        n:=n+1;
        PushPos(#OtgOrder);
        }
      }
    while TreeGetNext(trOtgOrder);
  FOR (i:=1; i<=n; i:=i+1)
    {
    PopPos(#OtgOrder);
    TreeCloseNode(trOtgOrder);
    }
  PopPos(#OtgOrder);
  if (LevelClosed)
    TreeOpenNode(trOtgOrder);
  TreeJumpToRecord (trOtgOrder,OtgOrder.nRec);
  RescanPanel(#OtgOrder);
  }

HandleEvent

cmTreeTop       : Node := 0;
cmTreeUp        : Node := OtgOrder.cOwner;
cmTreeDown      : Node := OtgOrder.nRec;
cmTreeNodeType  : if (OtgOrder.IsLeaf = 1) TreeSetNodeType(trOtgOrder,2);
cmTreeNeedOwner : TreeJumpToRecord (trOtgOrder,OtgOrder.cOwner) ;

cmPickClass: // Alt-C
  if ((UpdateTable) and (OtgOrder.NRec <> 0))
    RunInterface('ExClassifier', word(CurTableCode), OtgOrder.NRec);

cmPickAttr: // Alt-A
  if ((UpdateTable) and (OtgOrder.NRec <> 0))
    RunInterface('Attribute', word(CurTableCode), OtgOrder.NRec);

end; // HandleEvent

end; // Panel

HandleEvent

cmInit :
  {
  Init_arraySHL;
  Node := 0;
  MarkerOtg:=InitMarker('MOtgOrder',8,100,10);
  var MarkerCount, i : longint; // счетчики записей в маркере
  var pickrec        : comp;
  MarkerCount:=GetMarkerCount(MarkerOtg);
  ReSetBounds(#OtgOrder) ;
  FOR ( i:=0; i<MarkerCount; i:=i+1 )
    {
    if GetMarker(MarkerOtg,i,pickrec)
      if (GetFirst OtgOrder where ((pickrec == OtgOrder.NRec)) = tsOk )
        if ItemAccessDenided (pStatus,OtgOrder.Status)
          {
          AtDeleteMarker(MarkerOtg,i);
          dec(i);
          dec(MarkerCount);
          }
    }
  SetBounds(#OtgOrder);
!  if ((prmOtgOrder <> 0) and (OneLevel = false))
!    if ( (not OkOne) and
!         (GetFirst OtgOrder where ((prmOtgOrder == OtgOrder.nRec)) = tsOk) ) {};
  if (prmOtgOrder <> 0)
    {
    if (GetFirst OtgOrder where ((prmOtgOrder == OtgOrder.nRec)) = tsOk) {};
    }
  else
    if (OneLevel)
      if (GetLast OtgOrder = tsOk) {};
  SetMyFormat;
  PutCommand(cmValue1);
  }

cmValue1 :
  {
  if (not OneLevel)
    TreeJumpToRecord (trOtgOrder,prmOtgOrder) ;
  ReScanPanel(#OtgOrder) ;
  }

cmDefault :
  {
  prmOtgOrder := OtgOrder.nRec;
  if ( (not OkOne) and isValid(#OtgOrder) )
    if ItemAccessDenided (pStatus,OtgOrder.Status)
      {
      message('Нельзя пометить распоряжение на отгрузку с данным статусом !');
      Abort;
      EXIT;
      }
  if (OkOne)
    if ( (GetMarkerCount(MarkerOtg) = 0) and
         isValid(#OtgOrder) )
      if (OneMarkPick(true) = false)
        {
        Abort;
        EXIT;
        }
  }

cmDone :
  DoneMarker(MarkerOtg,'MOtgOrder');

cmMarkUnMark : // Если на группа то выбирать все из группы
  {
  if SearchMarker(MarkerOtg,OtgOrder.NRec,IndexOtg)
    DeleteMarker(MarkerOtg,OtgOrder.NRec)
  else
    OneMarkPick(true);
  SetMyTitle;
  if (isTreeFormat)
    TreeGetNext(trOtgOrder);
  RescanPanel(#OtgOrder);
  }

cmSelectAll :
  {
  PushPos(#OtgOrder);
  KillPick;
  var ret  : word;
  ResetBounds(#OtgOrder)
  _loop OtgOrder
    {
    if (OtgOrder.NRec <> 0)
      OneMarkPick(false);
    }
  SetBounds(#OtgOrder);
  SetMyTitle;
  PopPos(#OtgOrder);
  ReReadRecord;
  RescanPanel(#OtgOrder);
  }

cmUnSelectAll :
  {
  KillPick;
  RescanPanel(#OtgOrder);
  ReReadRecord;
  }

cmShowAll:
  {
  if (isTreeFormat = false)
    EXIT;
  MarkGroup;
  SetMyTitle;
  TreeGetNext(trOtgOrder);
  RescanPanel(#OtgOrder);
  }

cmHideAll:
  {
  if (isTreeFormat = false)
    EXIT;
  UnMarkGroup;
  SetMyTitle;
  TreeGetNext(trOtgOrder);
  RescanPanel(#OtgOrder);
  }

end; // HandleEvent

end. // Interface