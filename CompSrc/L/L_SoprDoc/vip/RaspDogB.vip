/*
 ╔═══════════════════════════════════════════════════════════════════════════╗
 ║ Назначение    : автоматическое формирование накладных по ДО               ║
 ╚═══════════════════════════════════════════════════════════════════════════╝
*/

//автоматическое формирование приходных накладных по ДО
//согласно ПКП для группы VIP-договоров
//ПИР 101.25418

#include DelSopr.vih
#include makenakl.vih
#include DOfuns.vih
#include SDfuns.vih

#include docbuf.inc   // Универсальный буфер для формирования шапки документа
#include spdocbuf.inc // Универсальный буфер для формирования спецификации документа
#ifdef __MTR_TO_SPEC__
#include MTRFuncs.vih           // функции целевого учета
#end

//******************************************************************************

#doc
Назначение:
  автоматическое формирование приходных накладных по ДО

  разрез формирования распределения: ДО - Договор (Склад) - ПКП
  1. при распределении кол-во в ордерах относится к планам с меньшей датой (dInput).
  2. распределение также начинается с планов с меньшей датой (dInput)

      Функция  "Формирование накладных  с распределением  по ПКП  VIP-договоров" на  основе
  вышеперечисленных данных будет  формировать приходные  накладные, в  которых МЦ  будут
  распределены  по  складам (одна  накладная -  один склад),  указанным в  договорах в  поле
  "дополнительная   классификация"  пропорционально   остатку  необеспеченного   количества,
  указанного в календарных планах договоров. Будут рассматриваться только те  ПКП, в  период
  действия которых будет попадать данная приходная накладная (дата ввода накладной совпадает
  с датой ввода ДО). Если в договоре таких ПКП два  или больше,  то рассматривается  сначала
  тот,  который  имеет  более  раннюю  дату ввода  (CalPlan.dInput). При  этом по  приходным
  складским ордерам будет рассчитано  ранее оприходованное  на склады  количество (в  расчет
  выполняетя по настройке - берутся все ордера за период от  мин.даты всех  ПКП договора  до
  макс.даты всех ПКП договора ИЛИ только ордера, привязанные к ПКП договора), чтобы с учетом
  полученного распределения не было  перебора по  какому-либо из  договоров. Если  останется
  свободное  количество МЦ,  то по  нему также  должны быть  сформированы накладные,  но
  распределение  по  складам должно  осуществляться на  основании данных  из ПКП  следующего
  периода  (ТОЖЕ  ПО  НАСТРОЙКЕ).  Если  в  результате  формирования   накладных,  все   ПКП
  VIP-договоров рассмотрены, а в договоре осталась спецификация, по которой не  сформированы
  накладные, то формируется накладная на остаток кол-ва с номером 000 без привязки к складу

Параметры:
  pNRec - ссылка на ДО
#end

//******************************************************************************

Interface MakeRaspByDOGB;

#include DOfuns.var
#include SDfuns.var
//распределение в разрезе ДОГОВОР - ПЛАН
Table STRUCT TmpDogRasp "Договора в распределении"
(
  NRec        : comp,
  cDog        : comp   "ссылка на договор",
  cAppDog     : comp   "ссылка на доп.соглашение",
  cPlan       : comp   "ссылка на ПКП"
)
With Index
(
  TmpDogRasp01 = NRec (Surrogate, Unique),
  TmpDogRasp02 = cDog + cAppDog + cPlan,
  TmpDogRasp03 = cDog + cPlan
);

//распределение по подразделению
Table STRUCT TmpMCRasp "Распределение МЦ"
(
  cSpStep     : comp   "ссылка на спецификацию",
  cPodr       : comp   "ссылка на подразделение",
  cDogRasp    : comp   "ссылка на TmpDogRasp",
  cMC         : comp   "ссылка на матценность",
  KolUth      : double "Количество в учетных единицах",
  KolPlan     : double "Суммарное кол-во по ПКП, уч.ед.",
  KolOrd      : double "Суммарное кол-во по ордерам, уч.ед.",
  KolOrd2     : double "Для протокола",
  KolRasp     : double "Потребность в кол-ве, уч.ед.",
  Kol         : double "К-во в отп.ед., с учетом округления",
  dMin        : date   "Нач. дата отгрузки по всем ПКП",
  dMax        : date   "Кон. дата отгрузки по всем ПКП",
  dInput      : date   "Дата ввода договора,ПКП"
)
With Index
(
  TmpMCRasp01 = cSpStep + cPodr + cDogRasp + dInput,
  TmpMCRasp02 = cPodr + cMC + cDogRasp,
  TmpMCRasp03 = cDogRasp + cMC,
  TmpMCRasp04 = cMC + cPodr + dInput,
  TmpMCRasp05 = cSpStep + cDogRasp //для протокола
);

Table STRUCT TmpMCKol "Количество МЦ"
(
  cMC         : comp    "ссылка на матценность",
  cPodr       : comp    "ccылка на склад",
  cDogRasp    : comp    "ccылка на разрез",
  KolRasp     : double  "Распред. кол-во  по МЦ",
  KolOrd      : double  "К-во в ордерах по складу",
  isRasp      : boolean "произведено распределение"
)
With Index
(
  TmpMCKol01 = cMC + cDogRasp,
  TmpMCKol02 = cMC + cPodr
);

Table STRUCT TmpListDog "распределенные договора,согл."
(
  cDog    : comp "ссылка на договор",
  cSpStep : comp "ссыкла на спецификацию"
)
With Index
(
  TmpListDog01 = cDog + cSpStep
);

Table STRUCT TmpListPlan "распределенные ПКП"
(
  cPlan   : comp "ссылка на ПКП",
  cSpStep : comp "ссыкла на спецификацию"
)
With Index
(
  TmpListPlan01 = cPlan + cSpStep
);

Table STRUCT TmpProtKol "кол-во для протокола"
(
  cSopr   : comp "ссылка на накладную",
  cSpSopr : comp "ссыкла на спецификацию",
  KolPlan : double "кол-во по плану",
  KolOrd  : double "кол-во в ордерах"
)
With Index
(
  TmpProtKol01 = cSopr + cSpSopr
);

create view
var
   pNRec    : comp;    //ДО
   pGrDog   : comp;    //ссылка на группу договоров
   pMC      : comp;    //ссылка на матценность
   pSpStep  : comp;
   pCurDogRasp : comp; //ссылка на текущий разрез

   _dRasp   : date;    //дата проверки периода договора(ПКП)
   e        : double;  //точность в количестве
   iNaklCount: integer;//кол-во накладных (для визуализации)
   wCalcKolOrd: word;  //алгоритм подсчета кол-ва в ордерах
from
   KatSopr, SpSopr,
   SDocBuf, SpDocBuf, SpDocBuf_Ex,
   SoprOrdB,

   Synonym KatSopr KatSopr2,

   BaseDoc, StepDoc,
   SpStep (SpStep02),

   SpGrSch,
   Dogovor,
   Synonym Dogovor Dogovor2,
   CalPlan,
   IerDog,
   IerCalPl,

   SpDocs,
   Synonym SpDocs SpDocs2,
   KatOtpEd,
   Synonym KatOtpEd KatOtpEd2,
   Synonym KatOtpEd KatOtpEdDocs,

   KatPodr,
   SklOrder,
   SpOrder,
   GroupSch,

   TmpMCRasp,
   TmpMCKol,
   TmpDogRasp,
   TmpProtKol,
   TmpListPlan,
   TmpListDog

where
((
   pNRec             ==  BaseDoc.NRec       and
   BaseDoc.Nrec      ==  StepDoc.cBaseDoc   and
   StepDoc.Nrec      ==  SpStep.cStepDoc    and
   word(1)           ==  SpStep.PrMC (noindex) and
   SpStep.cOtpEd     ==  KatOtpEd.NRec      and
   SpStep.cMCUsl     ==  KatMC.NRec         and
   KatMC.cEd         ==  KatEd.NRec         and

   StepDoc.NRec      ==  KatSopr.cStepDoc   and
   word(101)         ==  KatSopr.VidSopr    and
//   SpStep.NRec       ==  SpSopr.cSpStep     and //?!!
//   KatSopr.Nrec      ==  SpSopr.cSopr       and

   pGrDog            ==  SpGrSch.cGroupSch  and
   word(1)           ==  SpGrSch.wList      and
   SpGrSch.cBaseDoc  ==  Dogovor2.nRec      and

   Dogovor2.nRec     ==  IerDog.cUpRec      and
   word(1)           ==  IerDog.IsLeaf      and
   IerDog.cRec       ==  Dogovor.NRec       and
   Dogovor.NRec      ==  IerCalPl.cDogovor  and
   word(1)           ==  IerCalPl.IsLeaf    and
   IerCalPl.cRec     ==  CalPlan.nRec       and


   CalPlan.cOrg      ==  KatOrg.nRec        and
   word(403)         ==  SpDocs.TiDk        and //ПКП
   CalPlan.nRec      ==  SpDocs.cDoc        and
   SpDocs.cOtpEd     ==  KatOtpEdDocs.Nrec  and

   Dogovor2.cDopKlas ==  KatPodr.NRec       and //привязка склада к верхнему уровню договоров
   word(0)           ==  SklOrder.SP        and //склад
   word(0)           ==  SklOrder.VidOrder  and //приходный ордер
   KatPodr.Nrec      ==  SklOrder.cPodr

))

bounds  SpecifOrder = SklOrder.Nrec  ==  SpOrder.cSklOrder  and
                      pMC            ==  SpOrder.cMC

bounds  SpecifDog   = Dogovor.TiDk   ==  SpDocs2.TiDk  and
                      Dogovor.Nrec   ==  SpDocs2.cDoc

bounds  SpecifDog2  = SpDocs2.cOtpEd  ==  KatOtpEd2.NRec

bounds  _TmpMCRasp  = pSpStep          ==  TmpMCRasp.cSpStep   and
                      KatPodr.NRec     ==  TmpMCRasp.cPodr     and
                      TmpDogRasp.NRec  ==  TmpMCRasp.cDogRasp
                      ordered by TmpMCRasp.dInput

bounds _TmpDogRasp  = pCurDogRasp      ==  TmpDogRasp.NRec
;

Parameters
  pNrec;

Form frmProt('rasp_err.out','ERRR') with novisual;
Form frmRasp('raspdog.out','RaspDog') with novisual;

#ifdef __MTR_TO_SPEC__
#include MTRFuncs.var         // oMTRFun          функции целевого учета
#end

#include do2bufer.vpp
//общие функции распределения
#include RaspDog.vpp

//проверка привязки подразделений
function CheckPodrInDg (aGrDog : comp) : boolean;
begin

  pGrDog := aGrDog;
  CheckPodrInDg := true;
  if GetFirst GroupSch = tsOk
   _Loop SpGrSch
     if (Dogovor2.Status = 1) and (Dogovor2.cDogovor = 0)
       if GetFirst KatPodr <> tsOk
       {
         frmProt.write('Для договора ' + Dogovor2.Descr + '\' + Dogovor2.NoDoc +
                       ' от ' + string(Dogovor2.dDoc) + ' не задано подразделение ' +
                       '(Расширенная информация -> Назначение)');
         CheckPodrInDg := false;
       }
end;

//расчет общего кол-ва для каждой МЦ спецификации в учетных единицах
function PreparKolSpecif : integer;
var
  i : integer;
begin

  ResetBounds(tnTmpMCRasp);
  delete all TmpMCRasp;
  SetBounds(tnTmpMCRasp);

  ResetBounds(tnTmpDogRasp);
  delete all TmpDogRasp;
  SetBounds(tnTmpDogRasp);
  pCurDogRasp := comp(0);

  i := 0;
  _Loop SpStep
  {
    i := i + 1;
  }//_Loop

  PreparKolSpecif := i;

end;

//распределенные планы
function CheckPlan(aPlan,aRec: comp): boolean;
{
  if GetFirst TmpListPlan where ((aPlan == TmpListPlan.cPlan and
                                  aRec  == TmpListPlan.cSpStep )) = tsOk
    CheckPlan := false
  else
  {
    CheckPlan := true;
    TmpListPlan.cPlan   := aPlan;
    TmpListPlan.cSpStep := aRec;
    insert current TmpListPlan;
  }
}

//распределенные договора
function CheckDog(aDog,aRec: comp): boolean;
{
  if GetFirst TmpListDog where ((aDog == TmpListDog.cDog and
                                 aRec == TmpListDog.cSpStep)) = tsOk
    CheckDog := false
  else
  {
    CheckDog := true;
    TmpListDog.cDog    := aDog;
    TmpListDog.cSpStep := aRec;
    insert current TmpListDog;
  }
}

//распределенное кол-во по тек.позиции спецификации (в уч. единицах) ?!!
function KolRaspInSpStep (aMC, aPodr, aDogRasp: comp): double;
var
  tKol: double;
{
  ReSetBounds(#TmpMCRasp);
  tKol := double(0);
  _Loop TmpMCRasp where ((aMC      == TmpMCRasp.cMC    and
                          aPodr    == TmpMCRasp.cPodr  and
                          aDogRasp == TmpMCRasp.cDogRasp ))
     tKol := tKol + TmpMCRasp.KolUth;

  SetBounds(#TmpMCRasp);
  KolRaspInSpStep := tKol;
}

//сохранение остатка по тек. позиции
procedure SaveKolPodr (aMC,aPodr : comp; aKol : double; aIsRasp: boolean);
begin
    if GetFirst TmpMCKol
       where (( aMC   ==  TmpMCKol.cMC  and
                aPodr ==  TmpMCKol.cPodr )) = tsOk
    {
       TmpMCKol.KolOrd  := aKol;
       TmpMCKol.IsRasp  := aIsRasp;
       update current TmpMCKol;
    }
    else
    {
      ClearBuffer(tnTmpMCKol);
      TmpMCKol.cMC     := aMC;
      TmpMCKol.cPodr   := aPodr;
      TmpMCKol.KolOrd  := aKol;
      TmpMCKol.IsRasp  := aIsRasp;
      insert current TmpMCKol;
    }
end;

function GetKolPodr (aMC,aPodr : comp; var aIsRasp: boolean) : double;
begin
    GetKolPodr := comp(0);
    aIsRasp := false;
    if GetFirst TmpMCKol
       where (( aMC   ==  TmpMCKol.cMC  and
                aPodr ==  TmpMCKol.cPodr )) = tsOk
    {
       GetKolPodr := TmpMCKol.KolOrd;
       aIsRasp    := TmpMCKol.IsRasp;
    }
end;

//расчет оприходованного количества для каждой МЦ спецификации накладной
//за период действия ПКП
function CalcKolInOrder (aMC : comp) : boolean;
var
  tKol, tKolOrd: double;
  isBreak: boolean;

begin
  delete all TmpMCKol;

  pMC := aMC;
  if (wCalcKolOrd = 1)
    AddBounds(tbSpecifOrder)
  else
    ResetBounds(#SklOrder);

  CalcKolInOrder := true;

  if GetFirst GroupSch = tsOk
   _Loop SpGrSch
    if (Dogovor2.Status = 1) and (Dogovor2.cDogovor = 0)
     {
      if (GetFirst KatPodr = tsOk)
      {
       ResetBounds(#TmpDogRasp);
       _Loop TmpDogRasp
        //считать кол-во во всех ордерах за период
        if (wCalcKolOrd = 1)
        {
          isBreak := false;
          //приходные ордера относятся к планам, начиная с планов с меньшей датой
          _Loop TmpMCRasp
          {
            tKol := double(0);
            _Loop SklOrder
             if (TmpMCRasp.dMin <= SklOrder.dOrd) and
                (TmpMCRasp.dMax >= SklOrder.dOrd)
            {
             _Loop SpOrder
               tKol := tKol + SpOrder.Kol;
            }

            tKolOrd := GetKolPodr(TmpMCRasp.cMC,TmpMCRasp.cPodr,false);
            tKol := tKol - tKolOrd;
            if (tKol < 0) tKol := 0;

            //проверка превышения плана
            if (TmpMCRasp.KolPlan > tKol)
              isBreak := true
            else
              tKol := TmpMCRasp.KolPlan;

            TmpMCRasp.KolOrd  := tKol;
            TmpMCRasp.KolOrd2 := tKol;
            update current TmpMCRasp;
            SaveKolPodr (TmpMCRasp.cMC,TmpMCRasp.cPodr,tKolOrd + tKol,false);
            if isBreak break;
          }
        }
       //считать кол-во в ордерах по ПКП договоров
        else
         if (GetFirst TmpMCRasp = tsOk)
         {
           tKol := double(0);
           _Loop KatSopr2 where ((TmpDogRasp.cDog    == KatSopr2.cDogovor     and
                                  TmpDogRasp.cAppDog == KatSopr2.cAppDogovor  and
                                  TmpDogRasp.cPlan   == KatSopr2.cCalPlan     ))
             _Loop SklOrder where ((KatSopr2.NRec == SklOrder.cSopr))
             if (SklOrder.VidOrder = 0) and //приходный
                (SklOrder.SP       = 0)     //склад

//              if (TmpMCRasp.dMin <= SklOrder.dOrd) and
//                 (TmpMCRasp.dMax >= SklOrder.dOrd)
// берутся все ордера, связанные к накладной
              {
                _Loop SpOrder where (( SklOrder.NRec  ==  SpOrder.cSklOrder  and
                                       aMC            ==  SpOrder.cMC        ))
                  tKol := tKol + SpOrder.Kol;
              }
           TmpMCRasp.KolOrd  := tKol;
           TmpMCRasp.KolOrd2 := tKol;
           update current TmpMCRasp;
         }
       SetBounds(#TmpDogRasp);
      }
  }

  if (wCalcKolOrd = 1)
    SubBounds(tbSpecifOrder)
  else
    SetBounds(#SklOrder)
//  RereadRecord(tnTmpMCRasp);
end;


//расчет планируемого кол-ва в соответствии с ПКП для текущей МЦ спецификации накладной
//на период действия ПКП в учетных единицах измерения
function CalcKolInCalPlan (aMC : comp) : boolean;
var
  tKol,koefp : double;
begin

  CalcKolInCalPlan := true;
  AddBounds  (tbSpecifDog);
  AddBounds  (tbSpecifDog2);

  if getfirst GroupSch = tsOk
  {
   //заполнение TmpMCRasp данными из договоров и подсчет уже распределенного кол-ва
   //текущим распределением
   _Loop SpGrSch
    if (Dogovor2.Status = 1) and (Dogovor2.cDogovor = 0)
     if GetFirst KatPodr = tsOk
     {
      //подсчет кол-ва в разрезе СКЛАД-ПЛАН
      _Loop IerDog
       if Dogovor.Status = 1
        if GetFirst IerCalPl = tsOk  //подсчет по ПКП
        {
         _Loop IerCalPl
          if (IerCalPl.cUpRec = IerCalPl.cRec)
           if CalPlan.Status = 1
            if (CalPlan.dFrom <= _dRasp)
             if (CalPlan.DtO  >= _dRasp)
              if CheckPlan(CalPlan.NRec,SpStep.NRec)
              {
               tKol := double(0);
               _Loop SpDocs
                if SpDocs.Direct = 1
                 if SpDocs.cMcUsl = aMC
                 {
                   koefp := 1;
                   if SpDocs.cOtpEd <> 0 koefp := KatOtpEdDocs.koef;
                   tKol := tKol + SpDocs.Kol*koefp;
                 }
               if tKol > double(0)
               {
                 GetTmpDogRasp(Dogovor2.NRec,
                               if(Dogovor.cDogovor=0,comp(0),Dogovor.NRec),
                               CalPlan.NRec);
                 InsTmpMcRasp(aMC, CalPlan.dInput);

                 if CalPlan.dFrom < TmpMCRasp.dMin
                   TmpMCRasp.dMin := CalPlan.dFrom;

                 if CalPlan.DtO > TmpMCRasp.dMax
                   TmpMCRasp.dMax := CalPlan.DtO;

                 TmpMCRasp.KolPlan := TmpMCRasp.KolPlan + tKol;
                 update current TmpMCRasp;
               }
              }
        }
        // подсчет кол-ва в разрезе СКЛАД - ДОГОВОР (СОЛГЛАШЕНИЕ)
        else  //подсчет по договору или соглашению
        {
         if (Dogovor.DBEG <= _dRasp)
          if (Dogovor.DEND >= _dRasp)
           if CheckDog(Dogovor.NRec,SpStep.NRec)
           {
             tKol := double(0);
             _Loop SpDocs2
              if SpDocs2.Direct = 1
               if SpDocs2.cMcUsl = aMC
               {
                 koefp := 1;
                 if SpDocs2.cOtpEd <> 0 koefp := KatOtpEd2.koef;
                 tKol := tKol + SpDocs2.Kol*koefp;
               }

             if tKol > double(0)
             {
               GetTmpDogRasp(Dogovor2.NRec,
                             if(Dogovor.cDogovor=0,comp(0),Dogovor.NRec),
                             comp(0));
               InsTmpMcRasp(aMC, Dogovor.dInput);

               if Dogovor.DBEG < TmpMCRasp.dMin
                  TmpMCRasp.dMin := Dogovor.DBEG;

               if Dogovor.DEND > TmpMCRasp.dMax
                  TmpMCRasp.dMax := Dogovor.DEND;

               TmpMCRasp.KolPlan := TmpMCRasp.KolPlan + tKol;
               update current TmpMCRasp;
             }
           }

        }

     }
     else CalcKolInCalPlan := false;
  }

  SubBounds(tbSpecifDog2);
  SubBounds(tbSpecifDog);

end;

//расчет недопоставленного кол-ва для текущей МЦ спецификации накладной в соответствии с ПКП
//в учетных единицах измерения
function CalcKolUth (aGrDog : comp) : boolean;
begin
    pGrDog := aGrDog;
    CalcKolUth := true;

    pSpStep := SpStep.NRec;

    if not CalcKolInCalPlan(SpStep.cMCUsl)
       CalcKolUth := false;

    if not CalcKolInOrder(SpStep.cMCUsl)
       CalcKolUth := false;
end;

//Вставка накладных
Procedure InsertAllNakl;
var
  pMakeSoprByBuff: MakeSoprByBuff;
  res: word;
  tRec: comp;
{
  // это чтобы не показывалось распределение по складам
  SaveMyDsk(word(0),'ShowRaspr');
  // чтобы курс запрашивался
  SaveMyDsk (false, 'MakeSoprByBuff_GetCurse');

   StartNewVisual(vtIndicatorVisual,vfTimer,'Формирование накладных',RecordsInTable(#TmpDogRasp));
  _loop TmpDogRasp
  {
     delete all SDocBuf;
     delete all SpDocBuf;
     FillNaklBuffer;
     SDocBuf.cDogovor    := TmpDogRasp.cDog;
     SDocBuf.cAppDogovor := TmpDogRasp.cAppDog;
     SDocBuf.cCalPlan    := TmpDogRasp.cPlan;
     Update current SDocBuf;

     _Loop TmpMCRasp where ((TmpDogRasp.NRec == TmpMCRasp.cDogRasp))
       if GetFirst SpStep where ((TmpMCRasp.cSpStep == SpStep.NRec)) = tsOk
     {
       FillSpNaklBuffer;
       SpDocBuf.KolSkl  := TmpMCRasp.Kol;
       SpDocBuf.KolFact := TmpMCRasp.Kol;
       Update current SpDocBuf;
     }

     SaveMyDsk(word(13),'RaspVIPDog');
     res := pMakeSoprByBuff.MakeDocument(BaseDoc.dDoc,frmProt.Handle,SDocBuf.Name,word(1));
     NextVisual;

     if (res = 0)
     {
       ReadMyDsk(tRec,'RaspVIPDogNRec',false);
       //установка склада,номера
       if GetFirst KatSopr where ((tRec == KatSopr.NRec)) = tsOk
       {
         iNaklCount := iNaklCount + 1;
         KatSopr.NSopr     := BaseDoc.NoDoc + '_' + lpadch(string(iNaklCount),'0',3);
         if GetFirst TmpMCRasp where ((TmpDogRasp.NRec == TmpMCRasp.cDogRasp)) = tsOK
           KatSopr.cPodrTo := TmpMCRasp.cPodr;
         update current KatSopr;
       }
     }

  }
  StopVisual('',0);
}

// Установка значений полей по умолчанию для SoprOrdB
procedure DefaultSoprOrdB;
{
  ClearBuffer(#SoprOrdB);
  SoprOrdB.cSoprDoc := KatSopr.NRec;
  SoprOrdB.cSpSopr  := SpSopr.NRec;
  SoprOrdB.cParty   := SpSopr.cParty;
  SoprOrdB.cVal     := SpSopr.cVal;
  SoprOrdB.Price    := SpSopr.Price;
  SoprOrdB.VPrice   := SpSopr.VPrice;
  SoprOrdB.cUKS     := SpSopr.cUKS;
  SoprOrdB.Price    := SpSopr.rPrice;
  SoprOrdB.VPrice   := SpSopr.rVPrice;
  SoprOrdB.cOtpEd   := SpSopr.cOtpEd;
  SoprOrdB.cMc      := SpSopr.cMCUsl;
}

//формирование SoprOrdB
procedure MakeSoprOrdB;
{
   StartNewVisual(vtIndicatorVisual,vfTimer,'Формирование разноски накладных по складским ордерам',iNaklCount);
  _Loop KatSopr
  {
     Update Current KatSopr;

    _Loop SpSopr where ((KatSopr.NRec == SpSopr.cSopr))
      if GetFirst SoprOrdB where ((KatSopr.NRec == SoprOrdB.cSoprDoc and
                                   SpSopr.NRec  == SoprOrdB.cSpSopr(noIndex) )) <> tsOk
    {
      DefaultSoprOrdB;
      SoprOrdB.cPodr   := KatSopr.cPodrTo;
      SoprOrdB.Kol     := SpSopr.KolFact;
      if (insert current SoprOrdB = tsOk)
      {
#ifdef __MTR_TO_SPEC__
        oMTRFun.CopySpecMTR(coSpSopr, SpSopr.nRec, coSoprOrdB, SoprOrdB.nRec);
#end
      }
    }
    NextVisual;
  }
  StopVisual('',0);
}

//сохранение остатка по тек. позиции
procedure SaveOstKol (aMC,aDogRasp : comp; aKol : double);
begin
    if GetFirst TmpMCKol
       where (( aMC      ==  TmpMCKol.cMC  and
                aDogRasp ==  TmpMCKol.cDogRasp )) = tsOk
    {
       TmpMCKol.KolRasp := TmpMCKol.KolRasp + aKol;
       update current TmpMCKol;
    }
    else
    {
      ClearBuffer(tnTmpMCKol);
      TmpMCKol.cMC      := aMC;
      TmpMCKol.cDogRasp := aDogRasp;
      TmpMCKol.KolRasp  := aKol;
      insert current TmpMCKol;
    }
end;

function GetOstKol (aMC,aDogRasp : comp) : double;
begin
    GetOstKol := comp(0);
    if GetFirst TmpMCKol
       where (( aMC      ==  TmpMCKol.cMC  and
                aDogRasp ==  TmpMCKol.cDogRasp )) = tsOk
    {
       GetOstKol := TmpMCKol.KolRasp;
    }
end;

//Распределение по складам в процентном отношении ПКП и спецификации
procedure  FillRasp;
var
  //все в уч.единицах по одной позиции накладной
  tAllKol, //общее кол-во к распределению по всем складам
  tKol,    //распределенное кол-во по одному складу
  tKolOst, //остаток превышения кол-ва по плану
  tKolUth, //нераспределенное кол-во
  tPart,   //доля по одному складу в общем кол-ве
  Koefp,   //коэффициэнт пересчета из учетных в отпускные
  tKolOrd,
  tKolRasp
  : double;
  tIsRasp: boolean;

begin
   delete All TmpMCKol;

  _Loop SpStep
  {
    tAllKol := double(0);

    _Loop TmpMCRasp ordered by index TmpMCRasp04
    if SpStep.NRec = TmpMCRasp.cSpStep
    {
      TmpMCRasp.KolOrd := TmpMCRasp.KolOrd +
                 GetOstKol(TmpMCRasp.cMC,TmpMCRasp.cDogRasp);//остаток текущего распределения

      TmpMCRasp.KolRasp := TmpMCRasp.KolPlan - TmpMCRasp.KolOrd;

      if TmpMCRasp.KolRasp < 0
         TmpMCRasp.KolRasp := 0;
      Update Current TmpMCRasp;

      tKolOrd := GetKolPodr (TmpMCRasp.cMC, TmpMCRasp.cPodr, false);
      SaveKolPodr(TmpMCRasp.cMC, TmpMCRasp.cPodr, tKolOrd + TmpMCRasp.KolRasp, false);

      tAllKol := tAllKol + TmpMCRasp.KolRasp;
    }

    if tAllKol > double(0)
     if GetFirst TmpMCRasp
           where ((SpStep.NRec == TmpMCRasp.cSpStep)) = tsOk
     {
       tKolUth := TmpMCRasp.KolUth;

      _LOOP TmpMCRasp ordered by index TmpMCRasp04
       if SpStep.NRec = TmpMCRasp.cSpStep
       {
         tKolRasp := GetKolPodr(TmpMCRasp.cMC,TmpMCRasp.cPodr,tIsRasp);
          if (tIsRasp)
            tKol := tKolRasp
          else
          {
            tPart := tKolRasp / tAllKol;
            tKol  := tKolUth * tPart;
          }

         //к распределению по складу
         tKolRasp := tKol;

         if tKol > TmpMCRasp.KolRasp //превышение плана
         {
           tKol    := TmpMCRasp.KolRasp;
         }

         if KatEd.Diskret = 1   //округление для дискретных уч.единиц
         {
            tKolRasp := Round(tKolRasp);
            tKol     := Round(tKol);
         }

         //контроль превышения кол-ва в позиции накладной
         if tKol > tKolUth
          if KatEd.Diskret = 1   //округление для дискретных уч.единиц
             tKol := trunc(tKolUth);
          else
             tKol := tKolUth;

         //распределено в уч.ед.
         tKolOst  := tKol;
         //остаток от распределения по складу
         tKolRasp := tKolRasp - tKol;

         Koefp := 1;
         if SpStep.cOtpEd <> comp(0) koefp := KatOtpEd.koef;

         //округление отпускных единиц
         if KatOtpEd.Diskret = 1
         {
           TmpMCRasp.Kol := Round(tKol/koefp);
           tKol    := TmpMCRasp.Kol*koefp;
         }
         else
         {
           TmpMCRasp.Kol := tKol/koefp;
         }

         //вычесть распределеное
         tAllKol := tAllKol - TmpMCRasp.KolRasp;
         tKolUth := tKolUth - tKol;
         Update Current TmpMCRasp;

         SaveKolPodr(TmpMCRasp.cMC, TmpMCRasp.cPodr, tKolRasp, true);
         SaveOstKol (TmpMCRasp.cMC, TmpMCRasp.cDogRasp, tKolOst);
       }//_loop TmpMCRasp
     }
  }//_loop
end;

//формирование накладной на нераспределенное кол-во
Procedure InsertNotRasp;
var
  pMakeSoprByBuff: MakeSoprByBuff;
  res : word;
  tRec: comp;
  tKol: double;
  bMake: boolean;
begin
  // это чтобы не показывалось распределение по складам
  SaveMyDsk(word(0),'ShowRaspr');

  StartNewVisual(vtIndicatorVisual,vfTimer,'Формирование накладной по остаткам',1);

  delete all SDocBuf;
  delete all SpDocBuf;

  FillNaklBuffer;

  NextVisual;

  bMake := false;
  _Loop SpStep
  {
    tKol := KolInSpSopr(SpStep.NRec,1);
    if (SpStep.KolSkl - tKol > e)
    {
       tKol := SpStep.KolSkl - tKol;

       FillSpNaklBuffer;

       SpDocBuf.KolSkl  := tKol;
       SpDocBuf.KolFact := tKol;
       Update current SpDocBuf;
       bMake := true;
    }

  }

  if (not bMake)
  {
    StopVisual('',0);
    EXIT;
  }

  SaveMyDsk(word(13),'RaspVIPDog');
  res := pMakeSoprByBuff.MakeDocument(BaseDoc.dDoc,frmProt.Handle,SDocBuf.Name,word(1));

  if (res = 0)
  {
    ReadMyDsk(tRec,'RaspVIPDogNRec',false);
    //установка номера
    if GetFirst KatSopr where ((tRec == KatSopr.NRec)) = tsOk
    {
      KatSopr.NSopr     := BaseDoc.NoDoc + '_' + lpadch(string(0),'0',3);
      KatSopr.cPodrTo := coGetTune('User.cCurSklad');
      if KatSopr.cPodrTo = comp(0)
        RunInterface(GetAnyPodr, KatSopr.cPodrTo, 0);

      update current KatSopr;
    }
    iNaklCount := iNaklCount + 1;
  }
  StopVisual('',0);
end;

//Запуск распределения на дату
Function AddRasp: boolean;
var
  iCount : integer;
  bError : boolean;
{
   AddRasp := false;
   bError  := false;

   iCount := PreparKolSpecif;

   //подсчет количества
   AddBounds(tb_TmpDogRasp);
   AddBounds(tb_TmpMCRasp);
   StartNewVisual(vtIndicatorVisual,vfTimer,'Распределение по складам на '+string(_dRasp),iCount);
   _Loop SpStep
   {
     if not CalcKolUth(coGetTune('Dog.GrVipDog'))
     {
       message('Ошибки в расчете количества');
       bError := true;
       break;
     }
     NextVisual;
   }
   SubBounds(tb_TmpMCRasp);
   SubBounds(tb_TmpDogRasp);

   //распределение
   if not bError FillRasp;
   StopVisual('Распределение завершено.',0);

   //формирование накладных
   InsertAllNakl;
   //формирование SoprOrdB
   MakeSoprOrdB;

   //проверка - все ли распределено
   _Loop SpStep
   {
     if abs(SpStep.KolSkl - KolInSpSopr(SpStep.NRec, 1)) > e
     {
       AddRasp := true;
       break;
     }
   }
   //сохранение информации по кол-ву (для протокола)
   SaveProtKol;
}

Handleevent
cmInit:
{
  abort;

  if wGetTune('Dog.DopKlas') <> cgKau_KatPodr
  {
      message('Необходимо установить значение настройки'#10#13 +
              'ОПЕРАТИВНЫЙ КОНТУР -> УПРАВЛЕНИЕ ДОГОВОРАМИ ->'#10#13 +
              'ДОПОЛНИТЕЛЬНАЯ КЛАССИФИКАЦИЯ ДОГОВОРОВ'#10#13 +
              'в значение: "Подразделения"!'  ) ;
      exit;
  }

  if not CheckPodrInDg (coGetTune('Dog.GrVipDog'))
  {
     Message('Не для всех договоров указаны подразделения');
     if (not frmProt.Error)
        frmProt.ShowFile('');
     exit;
  }

  if GetFirst SpStep <> tsOk
  {
    message('Нет спецификации...');
    exit;
  }

  //проверка ДО на наличие накладных
  if not CheckNakl
  {
     Message('У данного ДО есть накладные.'#10#13+
             'Формирование отменено.');
     exit;
  }

  var isOst: boolean;
  e           := doGetTune('Oper.MinKolMC');
  wCalcKolOrd := wGetTune('Doc.Buy.CalcAllOrderINRasp');
  _dRasp := BaseDoc.dDoc;
  delete all TmpListPlan;
  delete all TmpListDog;
  delete all TmpProtKol;

  iNaklCount := 0;

  DO
  {
    isOst := AddRasp;
    if isOst
    {
      case wGetTune('Doc.Buy.ReRaspMC') of
       0: isOst := false; //остаток пойдет на выбранный склад
       1: if Message('Остались нераспределенные матценности.'#10#13 +
                     'Распределить остаток на '+
                     string(Add_Months(_dRasp, 1))+'?', YesNo + Confirmation) = cmYes
            _dRasp := Add_Months(_dRasp, 1)
          else
            isOst := false;

       2: if RunDialog('GetDateRasp',_dRasp) = cmCancel
            isOst := false
      end;

      //формирование накладной на нераспределенное кол-во
      if not isOst
        InsertNotRasp;
    }
  }
  WHILE isOst;

  BaseDoc.cDogovor := Dogovor2.NRec;
  Update Current BaseDoc;

  message('Распределение по складам завершено');

  //протокол формирования
  PrintRasp;
}

end;
End.

GetDateRasp DIALOG
  StatusCtx scGalDial;
Fields
  _dRasp ('Дата распределения остатка'):date [,'DD/MM/YYYY'],noProtect;
Buttons
  cmOk,Default,,'Распределить остаток';
  cmCancel   ,,,'Выход';

<< 'Выбор даты'
 Остались не распределенные матценности.
 Выберите дату распределения остатка:

 `Дата распределения`  .@@@@@@@@@@@

  <.~П~родолжить.>     <. Отмена .>
>>
